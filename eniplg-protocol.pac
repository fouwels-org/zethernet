# Generated by binpac_quickstart

# ## TODO: Add your protocol structures in here.
# ## some examples:

# Types are your basic building blocks.
# There are some builtins, or you can define your own.
# Here's a definition for a regular expression:
# type ENIPLG_WHITESPACE = RE/[ \t]*/;

# A record is a collection of types.
# Here's one with the built-in types
# type example = record {
# 	
# };


enum command_codes {
    NOP                 = 0x00,
    LIST_SERVICES       = 0x04,
    LIST_IDENTITY       = 0x63,
    LIST_INTERFACES     = 0x64,
    REGISTER_SESSION    = 0x65,
    UNREGISTER_SESSION  = 0x66,
    SEND_RR_DATA        = 0x6F,
    SEND_UNIT_DATA      = 0x70,

    # Not Implemented
    INDICATE_STATUS     = 0x72,
    CANCEL              = 0x73,
    # Other values are Reserved for future usage or Reserved for legacy
    };

type ENIP_PDU(is_orig: bool) = record {
    header: ENIP_Header;
    body: case is_orig of {
        true  -> request    : ENIP_Request(header);
        false -> response   : ENIP_Response(header);
    };
} &byteorder=littleendian &length = 24 + header.length;

type ENIP_Header = record {
    command         : uint16;               # Command identifier
    length          : uint16;                # Length of body
    session_handle  : uint32;               # Session handle
    status          : uint32;               # Status
    sender_context  : uint64;             # Sender context
    options         : uint32;               # Option flags
} &let {
    handle: bool = $context.flow.enip_header(this);
} &byteorder=littleendian;

type ENIP_Request(header: ENIP_Header) = record {
    
    data : case(header.command) of {
        LIST_SERVICES       -> list_services : List_Services_Request(header);
        LIST_IDENTITY       -> list_identity : List_Identity_Request(header);
        LIST_INTERFACES     -> list_interfaces : List_Interfaces_Request(header);
        REGISTER_SESSION        -> register_session : Register_Session_Request(header);

        NOP                     -> nop : Nop(header);
        UNREGISTER_SESSION      -> unregister_session : UnRegister_Session(header);
        SEND_RR_DATA            -> send_rr_data : Send_RR_Data(header);
        SEND_UNIT_DATA          -> send_unit_data : Send_Unit_Data(header);
        default                 -> unknown : bytestring &restofdata;
    };
} &byteorder=littleendian;

type ENIP_Response(header: ENIP_Header) = record {

    data: case(header.command) of {
        LIST_SERVICES       -> list_services : List_Services_Response(header);
        LIST_IDENTITY       -> list_identity : List_Identity_Response(header);
        LIST_INTERFACES     -> list_interfaces : List_Interfaces_Response(header);
        REGISTER_SESSION    -> register_session : Register_Session_Response(header);

        UNREGISTER_SESSION  -> unregister_session : UnRegister_Session(header);
        SEND_RR_DATA        -> sendrr_data : Send_RR_Data(header);
        SEND_UNIT_DATA      -> send_unit_data : Send_Unit_Data(header);
        default             -> unknown : bytestring &restofdata;
    };
} &byteorder=littleendian;

# Body 
type Nop(header: ENIP_Header) = record {
    # None
} &let {
    handle: bool = $context.flow.enip_nop(header, this);
} &byteorder=littleendian;

type List_Services_Request(header: ENIP_Header) = record {
    # None
} &let {
    handle: bool = $context.flow.enip_list_services_request(header, this);
} &byteorder=littleendian;

type List_Services_Response(header: ENIP_Header) = record {
    item_count : uint16;
    items : bytestring &restofdata;
} &let {
    handle: bool = $context.flow.enip_list_services_response(header, this);
} &byteorder=littleendian;

type List_Identity_Request(header: ENIP_Header) = record {
    # None
} &let {
    handle: bool = $context.flow.enip_list_identity_request(header, this);
} &byteorder=littleendian;

type List_Identity_Response(header: ENIP_Header) = record {
    item_count : uint16;
    items : bytestring &restofdata;
} &let {
    handle: bool = $context.flow.enip_list_identity_response(header, this);
} &byteorder=littleendian;

type List_Interfaces_Request(header: ENIP_Header) = record {
    # None
} &let {
    handle: bool = $context.flow.enip_list_interfaces_request(header, this);
} &byteorder=littleendian;

type List_Interfaces_Response(header: ENIP_Header) = record {
    item_count : uint16;
    items : bytestring &restofdata;
} &let {
    handle: bool = $context.flow.enip_list_interfaces_response(header, this);
} &byteorder=littleendian;

type Register_Session_Request(header: ENIP_Header) = record {
    protocol_version : uint16;
    options_flags : uint16;
} &let {
    handle: bool = $context.flow.enip_register_session_request(header, this);
} &byteorder=littleendian;

type Register_Session_Response(header: ENIP_Header) = record {
    protocol_version : uint16;
    options_flags : uint16;
} &let {
    handle: bool = $context.flow.enip_register_session_response(header, this);
} &byteorder=littleendian;

type Send_RR_Data(header: ENIP_Header) = record {
    InterfaceHandle : uint32;
    Timeout : uint16;
    encapsulated_packet : bytestring &restofdata;
} &let {
    handle: bool = $context.flow.enip_sendrr_data(header, this);
} &byteorder=littleendian;


type Send_Unit_Data(header: ENIP_Header) = record {
    InterfaceHandle : uint32;
    Timeout : uint16;
    encapsulated_packet : bytestring &restofdata;
} &let {
    handle: bool = $context.flow.enip_send_unit_data(header, this);
} &byteorder=littleendian;

type UnRegister_Session(header: ENIP_Header) = record {
    # None
} &let {
    handle: bool = $context.flow.enip_unregister_session(header, this);
} &byteorder=littleendian;